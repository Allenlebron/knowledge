# 第一周  
### 完成状态
  
- [x] 进行中
- [ ] 已完成
- [ ] 维护中

### 日期
####2019/06/03-2019/06/09    



## 列表   
* [~~swift 注解属性~~](http://www.russbishop.net/more-swift-attributes) 
    * [~~通过减少动态派送提升性能~~](http://ios.jobbole.com/81937/)
* [~~GCD系列~~](https://juejin.im/user/5cb1643e6fb9a0687177ae02/posts)
* [从 NSObject 的初始化了解 isa](https://draveness.me/isa)
* [基于 CocoaPods 的组件二进制化实践](https://dmanager.github.io/ios/2019/01/21/%E5%9F%BA%E4%BA%8ECocoaPods%E7%9A%84%E7%BB%84%E4%BB%B6%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%8C%96%E5%AE%9E%E8%B7%B5/)
* [CocoaPods，GitLab CI 与组件自动化发布](https://dmanager.github.io/ios/2019/01/27/CocoaPods-GitLabCI%E4%B8%8E%E7%BB%84%E4%BB%B6%E8%87%AA%E5%8A%A8%E5%8C%96%E5%8F%91%E5%B8%83/)
* [Dyld系列](https://blog.cnbluebox.com/blog/2017/06/30/dyld2/)
* [Block底层](https://bujige.net/blog/iOS-Blocks-01.html)
* [有货 iOS 数据非侵入式自动采集探索实践](https://www.infoq.cn/article/yoho-data-collection) 
* [让CocoaPods组件支持Carthage打包](https://triplecc.github.io/2018/04/07/2018-04-07-rang-cocoapodszu-jian-zhi-chi-carthageda-bao/)


## Knowledge Merge   

### 1. swift 注解属性  
swift语言虽然不允许开发者自定义注解属性，但是其自己定义了一些注解属性来解决特定的问题， 下面是一些比较常见的注解属性  

* `@IBOutlet`  
* `@IBAction`  
    以上两个是最常见的，在使用 storyboard 开发时，通过这两个属性来标记 变量和事件方法， storyboard将识别这些内容  

* `IBInspectable`  
* `GKInspectable`  
    通过以上注解标记属性，属性将在storyboard(GK) 面板中可进行编辑，通常用在兼容 storyboard 等可视化面板开发时，标注自定义属性，使其可以再面板中进行操作   

* `@IBDesignable`  
    通过此注解标记 UIView 或者 NSView 的子类， 其可显示在 Interface Builder 中，可以实时反馈修改   
    `@IBDesignable class myView: UIView {}`

* `@UIApplicationMain` 
* `@NSApplicationMain`  
    以上两个注解，替代了 main.swift 文件的实现

* `@available`  
    通过此注解标记方法或属性适用于不同的平台或系统   
    `@available(iOS 11, *)`   

* `@NSCopying`  
    通过此注解标记一个属性，复制它， 而不是属性本身的值。例如，标记一个引用类型，那么将复制出一个新的值

* `@nonobjc`
* `@objc` 
    标记一个方法或者属性以及类等是否 objective-C 可见   

* `@objcMembers`  
    此注解给类中属性批量的添加 `@objc` 注解   

* `@escaping`  
    此注解标记的值可以存储起来，以便后续代码可以继续使用，一般用作在闭包中  
    `func action(handler:@escaping () -> Void) {}`

* `@discardableResult` 
    标记当前方法的返回值可以不使用， 默认情况下，方法的返回值如果不使用编译器将报错   

    ```
    func add(a : int , b : int) -> int {}
    // 不使用  
    add(1,2)       // 系统警告，返回值没有接收使用
    _ = add(1,2)  // 不使用需要通过 _ 无效变量标记，后续丢弃  

    // 使用注解后  
    add(1,2)     // 系统不会警告

    ```
* `@inline`  
    这个注解提供编译器内联提示。有效值为 `__always`和 `never`  

* `@availability` 
    此注解标记方法或者属性仅在某些平台或者版本中可用  
    ```
    @availability(*, unavailable) 
    func test(){}  
    @availability(iOS, unavailable, message="you can't call this")
    func foo2() {}

    @availability(OSX, introduced=10.4, deprecated=10.6, obsoleted=10.10)
    @availability(iOS, introduced=5.0, deprecated=7.0)
    func foo3() {}
    ```

* `@noreturn`  
    标记一个方法或者函数一旦调用，将永远不会返回  

* `@testable`  
    在测试类中通过此注解导入模块，通过此种方式可以访问模块中的`internal`属性和方法，不过 private, fileprivate 不能访问   

* `@convention`  
    一般在C 与 swift 代码混用的地方容易出现，通过此注解，将其与之不同的语言转化为可用的形式      


* `@autoclosure`

### 2. GCD系列  
* 串行： 任务一个个的执行，上一个执行完毕开始执行下一个，不会出现时间重叠   
* 并行： 多个任务同时执行，会出现时间上的重叠，一个任务没执行完毕， 另一个任务已经开始执行   
* 队列： 遵守 `FIFO(先进先出)`原则。 


###### GCD 队列  
* 串行队列(Serial Dispatch Queue )  
* 并行队列 (Concurrent Dispatch Queue )


* 主队列 (Main Dispatch Queue)
* 全局并发队列 (Global Dispatch Queue )
* 自定义队列   

```
1. 主队列  
    dispatch_get_main_queue()  

2. 全局并发队列
    dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT,NULL)  
        参数1： 指定队列优先级 
        参数2： 保留字，当前无意义    

3. 自定义队列  
    dispatch_queue_create(,)  --->   dispatch_queue_t
        参数1： 对列名， 一般推荐使用逆序域名形式  
        参数2： 指定队列是串行/ 并行  
            DISPATCH_QUEUE_CONCURRENT    ========> 并行  
            DISPATCH_QUEUE_SERIAL / NULL ========> 串行


```

###### 任务  
* 同步执行  
    `dispatch_sync()` 添加任务，当任务执行完毕之前，当前线程阻塞     
* 异步执行
    `dispatch_async()` 此方法可能会开启新的线程执行(不一定开启，也可以使用已有线程，此处根据系统自动调度)    


###### 队列 + 执行 方式  
* 同步 + 并发  
    1. 所有任务在当前线程执行，不会开启新的线程(同步不会开启新线程)  
    2. 任务按顺序执行，没有并发的执行(并发队列，但只有一个线程执行任务)
    3. 会阻塞当前线程

* 异步 + 并发    
    1. 采用额外线程执行任务 
    2. 不会阻塞当前线程  

* 同步 + 串行 
    1. 所有任务在当前线程执行  
    2. 阻塞当前线程   

* 异步 + 串行   
    1. 任务会在额外线程执行，但任务是被在额外线程串行执行的  
    2. 不会阻塞当前线程
* 同步 + 主队列   
    1. __不可用，会导致当前线程死锁__   
    
* 异步 + 主队列  
    1. 任务都在当前线程执行  
    2. 不会阻塞当前线程  





###### GCD 死锁  
系统调用`__DISPATCH_WAIT_FOR_QUEUE__` 会导致死锁    
 
 * __原因__   

    ```
    1. thread =====> add ==========>任务1   
            任务1    runing   

    2. (同步) thread =====> add ==========> 任务2   
            阻塞  thread 
            暂停 任务1 ， 执行任务2  

    串行队列： 任务1 ， 任务2  

    当前： 
        任务1 执行需要依赖  任务2 执行完毕  

    总结：  
        串行队列保证了 任务1 执行完 执行任务2, 所以   任务2 执行依赖于 任务1   
        同步执行， 暂停 任务1 执行 任务2 ， 任务2 执行完毕接着执行 任务 1, 所以 任务1 执行依赖于 任务2 

    ```

* __方案__
    1. 不要在主线程中使用同步方式添加任务到主队列   
    2. 不要在自定义的串行队列中同步方式嵌套添加任务到该串行队列   
    
    
    |               | 串行                           | 并行             |  主队列  |
    | ------------- |:----------------------------: | :-----:| :-----: |
    | 同步           | 不开辟新线程；当前线程串行执行     | 不开辟新线程；当前线程串行执行 | 死锁 |
    | 异步           | 开辟新线程，新线程串行执行任务      |  开辟新线程(1/n条线程)； 并发执行任务 |  在当前线程顺序执行 |




##### 总结
* __同步提交block(任务), 首先是阻塞当前提交 block 线程__    
* __使用同步方式，提交一个任务到一个串行队列时， 如果提交这个任务的操作所在线程，也是处于串行队列中，那么将造成死锁__  



###### Group   
`dispatch_group` 本质是提交一组任务到队列中，采用异步方式执行，同时在执行完毕，可以给予响应   

1. 创建  
   `dispatch_group_t group = dispatch_group_create();`        

2. 添加任务  
    * 使用异步代码块的方式添加  `dispatch_group_async`  
    * 使用手动通知，在任务代码执行前 `dispatch_group_enter()`通知进入任务， 在任务执行完毕`dispatch_group_leave()`离开    
        > __此种方式可适用 异步网络请求__ 


3. 任务全部执行完毕回调   
    * `dispatch_group_wait`  
        此种方式会阻塞当前线程， 直到所有任务执行完毕，才会继续往下执行，所有 执行完毕的回调是写在 此代码之后的  
    * `dispatch_group_notify`
        添加一个异步执行的任务作为结束任务，当group中的任务全部完成，才会执行`dispatch_group_notify`中添加的异步任务，这种方式不会阻塞当前线程


######信号量(dispatch_semaphore)  
`dispatch_semaphore`俗称信号量，也称为信号锁，通常用在多线程编程中控制线程访问资源的数量， 一般主要有两个用途 1. __线程同步__ , 2. __资源加锁__   

1. `dispatch_semaphore_create`  
     创建一个带有初始值的信号量   
     > 初始值 =  0 ： 主要用于处理两个线程需要协调 =========》 线程同步
     > 初始值 > 0 : 主要用于管理有限资源， 资源大小等于值(通常用于多个线程操作) =========》 资源加锁   

2. `dispatch_semaphore_wait`
    __主要用于等待或减小信号量__, 每次调用此方法，信号量值会 - 1 一般有两种情况：  
    * `< 0`， 这个方法会一直等待，阻塞当前线程，直到信号量 + 1或者超时    
        ```
        主要用在线程同步中, 当  dispatch_semaphore_create(0)  时， 使用   dispatch_semaphore_wait() 使信号量减一， 
        此时会阻塞当前线程， 直到另外一个线程调用  dispatch_semaphore_signal 使信号量 + 1 等于 0 时， 当前线程被唤醒， 执行接下来的代码        
        ```  
    * `>= 0`, 此方法会直接返回，不会阻塞当前线程   
        ```
        当想对资源进行加锁， 控制资源同时最大访问数时， 可以使用  dispatch_semaphore_create(n)   初始化信号量为 n(对资源同时访问最大数为n)  
        在开始访问资源之前  dispatch_semaphore_wait()  信号量 - 1  
        在资源访问结束     dispatch_semaphore_signal() 信号量 + 1  

        当 n 个资源访问对象都没有访问结束时， 会阻塞当前线程，并且阻塞接下来的资源访问请求，直到有一个结束资源访问  

        ```

3. `dispatch_semaphore_signal`  
    当前信号量的值 `+ 1` , 直接返回，如果信号量的值当前 => 0 , 那么唤醒当前线程，继续执行    


4. 信号量释放  
    * 在使用阶段不能针对信号量释放 `semaphore = nil`  
    * 使用阶段不能针对信号量进行重新赋值   




###### 栅栏(dispatch_barrier)     
是一个类似于`dispatch_async()/dispatch_sync()` 的API， 可以将 block 任务添加到队列中， `barrier block` 只有提交到自定义的并发队列中才能真正成为一个 `栅栏`。 只有比它先提交任务执行完毕，才会去执行 `barrier block`, 只有 `barrier block` 执行完毕，在它之后添加的任务才会执行，__当`barrier block` 提交到并行队列或者全局队列上，其与`dispatch_async()/dispatch_sync()`无差别    

1. `dispatch_barrier_async`  
    在`dispatch_barrier_async` 之前添加到队列中的任务，会在 `barrier block` 执行前并发执行完毕， 执行 `barrier block`, 执行完毕， 开始并发执行在 `barrier block` 之后添加的任务   
2. `dispatch_barrier_sync`
    必须等待 当前  `barrier block` 执行完毕，才会将之后的任务加入队列， `dispatch_barrier_async` 则不会阻塞之后的任务入队列   

> ⚠️： 尽量不要在串行队列中使用 `dispatch_barrier_sync`


3. 应用  
    * 实现多读单写， 写操作写入到 `barrier block`执行， 读操作在一般的异步任务中   



###### Other  

* 延迟执行  
    `dispatch_after`   
* 一次执行  
    `dispatch_once`  
* 快速迭代  
    `dispatch_apply`  
    按照一定的次数将制定的任务追加到指定的队列中，并等待全部任务执行完毕 

